![Problem](https://github.com/seongjinkime/problem-solving/blob/master/images/14501.png)

### type : 완전탐색

#### 나의 접근
1. combination으로 가능한 모든 일수의 조합을 만드려고 시도 했다  
2. 두개의 조건을 통과 해야 그 다음 탐색이 가능 하도로 했다  
  ```
   a) day + t[here] < there  // 현재일 + 상담 일수 < 다음 상담일
   b) day + t[here] + there < n  // 현재일 + 상담 일수 + 다음 상담일 < 상담 가능일
  ```
 3. 탐색이 종료 될때 마다 최대값을 찾으려고 했다.
 
 
#### 오류 찾기
1. 다음 상담일과 상담일수는 다른 종류의 값이다.
  ```
  a) 상담일수 : 상담을 위한 소요 기간
  b) 다음 상담일 : 상담 날짜
  ```
  
#### 답안 및 주요 코드
1. 백준이의 행동을 두가지로 분류한다
  ```
  a) 상담을 한다
  b) 상담을 하지 않는다
  ```
2. 두가지의 경우를 나누어 탐색을 진행 한다
  ```
  a) dfs(day+t[day]) //현재일에 상담 소요 기간을 더함
  b) dfs(day+1)      //상담을 하지 않고 다음날로 넘어감
  ```
3. 탐색 과정
  ```
  a) 1일 부터 가능한 모든 상담을 해나감
  b) 2일 부터 가능한 모든 상담을 해나감
  c) 3일 부터 가능한 모든 상담을 해나감
  ...
  n) n일부터 가능한 모든 상담을 해나감
  ```
 4. 결론  
 + 모든 상담 가능 일수를 탐색하여 최대 값을 찾는다
 
 
 #### Code
 ```cpp
 void dfs(int day, int sum){
    if(day >= n+1){
        ret = max(ret, sum);
        return;
    }
    
    if(day+t[day]<=n+1 ){
        dfs(day+t[day], sum+p[day]);
    }
    if(day+1 <= n+1){
        dfs(day+1, sum);
    }
}
```

### 주의할점
1. 상담을 마치고 n+1일에 퇴사를 할 수 있으므로 종료 조건은 n+1이다

### 전략 BUILD
1. 가능한 모든 조합 탐색하는 경우에 유용하게 쓸 수 있는 방법이다
